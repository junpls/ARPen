//
//  ARPenTests.swift
//  ARPenTests
//
//  Created by Jan on 01.04.19.
//  Copyright Â© 2019 RWTH Aachen. All rights reserved.
//

import XCTest
import SceneKit
@testable import ARPen

class ARPenTests: XCTestCase {

    static let eps:Float = 0.001
    
    @IBOutlet var scene:SCNScene!

    override func setUp() {
        // Put setup code here. This method is called before the invocation of each test method in the class.
        scene = SCNScene()
    }

    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testCreateBigBox() {
        let bigBox = ARPBox(width: 1, height: 2, length: 3)
        let generatedGeometryExpectation = expectation(description: "Got geometry")
        let rightGeometryExpectation = expectation(description: "Right geometry")
        
        let timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { (timer) in
            if let geom = bigBox.geometryNode.geometry {
                generatedGeometryExpectation.fulfill()
                timer.invalidate()
                let vertices = self.vertices(node: bigBox.geometryNode)
                
                // As a heuristic, just check if 4 abritrary points exist
                if vertices.contains(where: { $0.distance(vector: SCNVector3(-0.5, -1.0, -1.5)) < ARPenTests.eps } )
                    && vertices.contains(where: { $0.distance(vector: SCNVector3(-0.5, -1.0, 1.5)) < ARPenTests.eps } )
                    && vertices.contains(where: { $0.distance(vector: SCNVector3(-0.5, 1.0, -1.5)) < ARPenTests.eps } )
                    && vertices.contains(where: { $0.distance(vector: SCNVector3(0.5, -1.0, -1.5)) < ARPenTests.eps } )
                {
                    rightGeometryExpectation.fulfill()
                }
            }
        }
        
        waitForExpectations(timeout: 0.5, handler: nil)
        
        addTeardownBlock {
            timer.invalidate()
        }
    }
    
    func testTransform() {
        let smallBox = ARPBox(width: 1, height: 1, length: 1)
        smallBox.position.x = -0.5
        smallBox.eulerAngles = SCNVector3(0, 0, Float.pi / 4)
        smallBox.scale = SCNVector3(1.41421358474619,1.41421358474619,1.41421358474619)
        
        // Just rebuild and apply transform multiple times to check if operations are idempotent as supposed
        smallBox.applyTransform()
        XCTAssertNoThrow(try smallBox.rebuild())
        smallBox.applyTransform()
        XCTAssertNoThrow(try smallBox.rebuild())
        smallBox.applyTransform()
        smallBox.applyTransform()
        XCTAssertNoThrow(try smallBox.rebuild())
        XCTAssertNoThrow(try smallBox.rebuild())
        let rightGeometryExpectation = expectation(description: "Right geometry")
        let rightNodeTransformExpectation = expectation(description: "Right node transform")
        let rightGeomTransformExpectation = expectation(description: "Right geometry transform")

        var f1 = false
        var f2 = false
        var f3 = false
        let timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { (timer) in
            if let geom = smallBox.geometryNode.geometry {
                let vertices = self.vertices(node: smallBox.geometryNode)

                // As a heuristic, just check if 4 abritrary points exist
                if vertices.contains(where: { $0.distance(vector: SCNVector3(x: -0.5, y: -0.5, z: -0.5)) < ARPenTests.eps } )
                    && vertices.contains(where: { $0.distance(vector: SCNVector3(x: -0.5, y: 0.5, z: -0.5)) < ARPenTests.eps } )
                    && vertices.contains(where: { $0.distance(vector: SCNVector3(x: -0.5, y: 0.5, z: -0.5)) < ARPenTests.eps } )
                {
                    if !f1 {
                        rightGeometryExpectation.fulfill()
                    }
                    f1 = true
                }
                
                if smallBox.worldPosition.distance(vector: SCNVector3(-0.5, 0, 0)) < ARPenTests.eps {
                    if !f2 {
                        rightNodeTransformExpectation.fulfill()
                    }
                    f2 = true
                }
                
                if smallBox.geometryNode.worldPosition.distance(vector: SCNVector3(-0.5, 0, 0)) < ARPenTests.eps {
                    if !f3 {
                        rightGeomTransformExpectation.fulfill()
                    }
                    f3 = true
                }
                
                if f1 && f2 && f3 {
                    timer.invalidate()
                }
            }
        }
        
        waitForExpectations(timeout: 5, handler: nil)
        
        addTeardownBlock {
            timer.invalidate()
        }
    }
    
    func testExtrude() {

        var ppoints = [SCNVector3]()
        ppoints.append(SCNVector3(-1, 0, -1))
        ppoints.append(SCNVector3(1, 0, -1))
        ppoints.append(SCNVector3(1, 0, 1))
        ppoints.append(SCNVector3(-1, 0, 1))
        
        var profile = ARPPath(points: ppoints, closed: true)
        profile.position = SCNVector3(1, 0, 0)
        profile.applyTransform()
        
        var epoints = [SCNVector3]()
        epoints.append(SCNVector3(-1, 0, -1))
        epoints.append(SCNVector3(-1, 2, -1))
        
        var extrusion = ARPPath(points: epoints, closed: false)
        extrusion.position = SCNVector3(1, 0, 0)
        extrusion.applyTransform()
        
        let rightGeomExpectation = expectation(description: "Right geometry")

        var timer:Timer? = nil
        if let pipe = try? ARPSweep(profile: profile, path: extrusion) {
            timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { (timer) in
                if let geom = pipe.geometryNode.geometry {
                    let vertices = self.vertices(node: pipe.geometryNode)
                    
                    if vertices.contains(where: { $0.distance(vector: SCNVector3(x: -1.0, y: 0.0, z: -1.0)) < ARPenTests.eps } )
                        && vertices.contains(where: { $0.distance(vector: SCNVector3(x: 1.0, y: 2.0, z: 1.0)) < ARPenTests.eps } )
                        && vertices.contains(where: { $0.distance(vector: SCNVector3(x: -1.0, y: 2.0, z: 1.0)) < ARPenTests.eps } )
                    {
                        XCTAssert(pipe.worldPosition.distance(vector: SCNVector3(1,0,0)) < ARPenTests.eps)
                        
                        rightGeomExpectation.fulfill()
                        timer.invalidate()
                    }
                }
            }
        }
        
        waitForExpectations(timeout: 5, handler: nil)
        
        addTeardownBlock {
            timer?.invalidate()
        }
    }
    
    func testBoolean() {
        let smallBox = ARPBox(width: 1, height: 1, length: 1)
        smallBox.position.x = -1
        let bigBox = ARPBox(width: 2, height: 2, length: 2)
        
        smallBox.position.y = 1
        bigBox.position.y = 1

        smallBox.applyTransform()
        bigBox.applyTransform()
        
        var timer:Timer? = nil
        let rightGeomExpectation = expectation(description: "Right geometry")

        if let bool = try? ARPBoolNode(a: bigBox, b: smallBox, operation: BooleanOperation.cut) {

            timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { (timer) in
                if let geom = bool.geometryNode.geometry {
                    let vertices = self.vertices(node: bool.geometryNode)
                    
                    print(vertices)
                    
                    if vertices.contains(where: { $0.distance(vector: SCNVector3(x: -1.0, y: -1.0, z: -1.0)) < ARPenTests.eps } )
                        && vertices.contains(where: { $0.distance(vector: SCNVector3(x: -0.5, y: -0.5, z: -0.5)) < ARPenTests.eps } )
                        && vertices.contains(where: { $0.distance(vector: SCNVector3(x: -0.5, y: 0.5, z: 0.5)) < ARPenTests.eps } )
                        && vertices.contains(where: { $0.distance(vector: SCNVector3(x: -1.0, y: 0.5, z: -0.5)) < ARPenTests.eps } )
                        && vertices.contains(where: { $0.distance(vector: SCNVector3(x: -1.0, y: 0.5, z: 0.5)) < ARPenTests.eps } )
                    {
                        XCTAssert(bool.worldPosition.distance(vector: SCNVector3(0,1,0)) < ARPenTests.eps)

                        rightGeomExpectation.fulfill()
                        timer.invalidate()
                    }
                }
            }
        }
        
        waitForExpectations(timeout: 5, handler: nil)
        
        addTeardownBlock {
            timer?.invalidate()
        }
    }
    
    /*
    func testBool() {
        let bigBox = ARPBox(width: 1, height: 2, length: 3)
        let smallBox = ARPBox(width: 1, height: 1, length: 1)
        smallBox.position.
    }*/

    func testPerformanceExample() {
        // This is an example of a performance test case.
        self.measure {
            // Put the code you want to measure the time of here.
        }
    }

    func vertices(node:SCNNode) -> [SCNVector3] {
        let vertexSources = node.geometry?.sources(for: SCNGeometrySource.Semantic.vertex)
        if let vertexSource = vertexSources?.first {
            let count = vertexSource.data.count / MemoryLayout<SCNVector3>.size
            return vertexSource.data.withUnsafeBytes {
                [SCNVector3](UnsafeBufferPointer<SCNVector3>(start: $0, count: count))
            }
        }
        return []
    }

}
